/////////////////////////////////////////////////////////////////////
//
// Модуль часто используемых функций работы с файлами
//
// (с) EvilBeaver, 2016
//
/////////////////////////////////////////////////////////////////////

// Проверяет существование файла или каталога
//
// Параметры:
//   Путь - Проверяемый путь
//
//  Возвращаемое значение:
//   Булево   - Истина, если файл/каталог существует
//
Функция Существует(Знач Путь) Экспорт

    Объект = Новый Файл(Путь);

    Возврат Объект.Существует();

КонецФункции // Существует()

// Проверяет существование файла
//
// Параметры:
//   Путь - Проверяемый путь
//
//  Возвращаемое значение:
//   Булево   - Истина, если файл существует
//
Функция ФайлСуществует(Знач Путь) Экспорт

    Объект = Новый Файл(Путь);

    Возврат Объект.Существует() И Объект.ЭтоФайл();

КонецФункции // ФайлСуществует()

// Проверяет существование каталога
//
// Параметры:
//   Путь - Проверяемый путь
//
//  Возвращаемое значение:
//   Булево   - Истина, если каталог существует
//
Функция КаталогСуществует(Знач Путь) Экспорт

    Объект = Новый Файл(Путь);

    Возврат Объект.Существует() И Объект.ЭтоКаталог();

КонецФункции // КаталогСуществует()

// Гарантирует наличие пустого каталога с указанным именем
//
// Параметры:
//   Путь - Строка - Путь к каталогу
//
Процедура ОбеспечитьПустойКаталог(Знач Путь) Экспорт

    ОбеспечитьКаталог(Путь);
    УдалитьФайлы(Путь, ПолучитьМаскуВсеФайлы());

КонецПроцедуры // ОбеспечитьПустойКаталог()

// Гарантирует наличие каталога с указанным именем
//
// Параметры:
//   Путь - Строка - Путь к каталогу
//
Процедура ОбеспечитьКаталог(Знач Путь) Экспорт

    Объект = Новый Файл(Путь);
    Если Не Объект.Существует() Тогда
        СоздатьКаталог(Путь);
    ИначеЕсли НЕ Объект.ЭтоКаталог() Тогда
        ВызватьИсключение "Не удается создать каталог " + Путь + ". По данному пути уже существует файл.";
    КонецЕсли;

КонецПроцедуры // ОбеспечитьКаталог()

// Копирует все файлы из одного каталога в другой
//
// Параметры:
//   Откуда - Строка - Путь к исходному каталогу
//   Куда - Строка - Путь к каталогу-назначению
//
Процедура КопироватьСодержимоеКаталога(Знач Откуда, Знач Куда) Экспорт

	ОбеспечитьКаталог(Куда);

	Файлы = НайтиФайлы(Откуда, ПолучитьМаскуВсеФайлы());
	Для Каждого Файл Из Файлы Цикл
		ПутьКопирования = ОбъединитьПути(Куда, Файл.Имя);
		Если Файл.ЭтоКаталог() Тогда
			КопироватьСодержимоеКаталога(Файл.ПолноеИмя, ПутьКопирования);
		Иначе
			КопироватьФайл(Файл.ПолноеИмя, ПутьКопирования);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Проверяет является ли каталог пустым.
// Генерирует исключение если каталог с указанным именем не существует.
//
// Параметры:
//   Путь - Строка - Путь к каталогу
//
// Возвращаемое значение:
//   Булево   - Истина, если каталог пуст
//
Функция КаталогПустой(Знач Путь) Экспорт

	Если НЕ КаталогСуществует(Путь) Тогда
		ВызватьИсключение "Каталог <" + Путь + "> не существует";
	КонецЕсли;

	МассивФайлов = НайтиФайлы(Путь, ПолучитьМаскуВсеФайлы(), Ложь);

	Возврат МассивФайлов.Количество() = 0;

КонецФункции // КаталогПустой(Знач Путь)

// Возвращает путь файла относительно корневого каталога
// регистро-независимая замена, что важно для Windows в некоторых сценариях
//
// Параметры:
//   ПутьКорневогоКаталога - <Строка> - путь корневого каталога
//   ПутьВнутреннегоФайла - <Строка> - путь файла
//   РазделительПути - Строка или Неопределено - все разделители в пути заменяются на указанный разделитель пути
//		если Неопределено, то разделители пути не заменяются
//
//  Возвращаемое значение:
//   <Строка> - относительный путь файла
//
Функция ОтносительныйПуть(Знач ПутьКорневогоКаталога, Знач ПутьВнутреннегоФайла, 
				Знач РазделительПути = Неопределено) Экспорт

	Если ПустаяСтрока(ПутьКорневогоКаталога) Тогда
		ВызватьИсключение "Не указан корневой путь в методе ФС.ОтносительныйПуть";
	КонецЕсли;

	ФайлКорень = Новый Файл(ПутьКорневогоКаталога);
	ФайлВнутреннийКаталог = Новый Файл(ПутьВнутреннегоФайла);

	ИмяДляРегулярки = ПодготовитьШаблонКИспользованиюВРегулярке(ФайлКорень.ПолноеИмя);
	РегулярноеВыражение = Новый РегулярноеВыражение(СтрШаблон("(%1)(.*)", ИмяДляРегулярки));
	Рез = РегулярноеВыражение.Заменить(ФайлВнутреннийКаталог.ПолноеИмя, "$2");

	Если Найти("\/", Лев(Рез, 1)) > 0 Тогда
		Рез = Сред(Рез, 2);
	КонецЕсли;
	Если Найти("\/", Прав(Рез, 1)) > 0 Тогда
		Рез = Лев(Рез, СтрДлина(Рез) - 1);
	КонецЕсли;
	Если РазделительПути <> Неопределено Тогда
		Рез = СтрЗаменить(Рез, "\", РазделительПути);
		Рез = СтрЗаменить(Рез, "/", РазделительПути);
	КонецЕсли;

	Если ПустаяСтрока(Рез) Тогда
		Рез = ".";
	КонецЕсли;

	Возврат Рез;
КонецФункции

// Возращает полный путь, приведенный по правилам ОС.
//
// Параметры:
//  ОтносительныйИлиПолныйПуть  - фрагмент или полный путь
//
// Возвращаемое значение:
//   Строка   - путь, оформленный по правилам ОС
//
Функция ПолныйПуть(Знач ОтносительныйИлиПолныйПуть) Экспорт
	Файл = Новый Файл(ОтносительныйИлиПолныйПуть);
	Возврат Файл.ПолноеИмя;
КонецФункции // ПолныйПуть(Знач ОтносительныйИлиПолныйПуть)

// Возращает полный путь, приведенный по правилам ОС.
//
// Параметры:
//  ОтносительныйИлиПолныйПуть  - фрагмент или полный путь
//
// Возвращаемое значение:
//   Строка   - путь, оформленный по правилам ОС
//
Функция НормализоватьПуть(Знач ОтносительныйИлиПолныйПуть) Экспорт
	Возврат ПолныйПуть(ОтносительныйИлиПолныйПуть);
КонецФункции // НормализоватьПуть(Знач ОтносительныйИлиПолныйПуть) Экспорт

// Проверяет, что пути равны с учетом правил ОС.
//
// Параметры:
//  ПервыйПуть - первый сравниваемый путь
//  ВторойПуть - второй сравниваемый путь
//
// Возвращаемое значение:
//   Истина, если пути равны, Ложь - если нет.
//
Функция ПутиРавны(ПервыйПуть, ВторойПуть) Экспорт
	Возврат ПолныйПуть(ПервыйПуть) = ПолныйПуть(ВторойПуть);
КонецФункции

// Удаляет рекурсивно файлы в каталоге с учетом маски.
//
// Параметры:
//  Каталог - каталог в котором удаляются файлы. Если путь указывает на конечный файл,
//             то он удаляется независимо от указания маски.
//  Маска - Маска файлов или Неопределено, если надо удалить все найденные файлы
//  Рекурсивно - удалять ли файлы в подкаталогах
//
Процедура УдалитьФайлы(Знач Каталог, Знач Маска = Неопределено, Знач Рекурсивно = Ложь) Экспорт
	
	Файл = Новый Файл(Каталог);
	Если Не Файл.Существует() Тогда
		Возврат;
	КонецЕсли;

	Если Не Файл.ЭтоКаталог() Тогда
		УдалитьФайлы(Файл.ПолноеИмя);
		Возврат;
	КонецЕсли;

	Если Маска = Неопределено Тогда
		Маска = ПолучитьМаскуВсеФайлы();
	КонецЕсли;

	УдаляемыеФайлы = НайтиФайлы(Каталог, Маска, Рекурсивно);
	
	// Непустые каталоги не могут быть удалены, поэтому каталоги,
	// подпадающие под маску удаляются во второй проход.
	УдаляемыеКаталоги = Новый ТаблицаЗначений();
	УдаляемыеКаталоги.Колонки.Добавить("Путь");
	УдаляемыеКаталоги.Колонки.Добавить("Уровень", Новый ОписаниеТипов("Число"));
	
	Для Каждого НайденныйФайл Из УдаляемыеФайлы Цикл
		Если НайденныйФайл.ЭтоКаталог() Тогда
			СтрКаталог = УдаляемыеКаталоги.Добавить();
			СтрКаталог.Путь = НайденныйФайл.ПолноеИмя;
			СтрКаталог.Уровень = СтрДлина(СтрКаталог.Путь);
		Иначе
			УдалитьФайлы(НайденныйФайл.ПолноеИмя);
		КонецЕсли;
	КонецЦикла;

	УдаляемыеКаталоги.Сортировать("Уровень Убыв");
	Для Каждого СтрКаталог Из УдаляемыеКаталоги Цикл
		УдалитьФайлы(СтрКаталог.Путь);
	КонецЦикла;

КонецПроцедуры

// Подготовить шаблон к использованию в регулярке путем экранирования служебных символов
//
// Параметры:
//  Шаблон	 - Строка - строка регулярного выражения без экранирования
//
// Возвращаемое значение:
//   Строка - подготовленный шаблон регулярного выражения с добавлением экранирования и заменой *
//
Функция ПодготовитьШаблонКИспользованиюВРегулярке(Знач Шаблон)

	СпецСимволы = Новый Массив;
	СпецСимволы.Добавить("\");
	СпецСимволы.Добавить("^");
	СпецСимволы.Добавить("$");
	СпецСимволы.Добавить("(");
	СпецСимволы.Добавить(")");
	СпецСимволы.Добавить("<");
	СпецСимволы.Добавить("[");
	СпецСимволы.Добавить("]");
	СпецСимволы.Добавить("{");
	СпецСимволы.Добавить("}");
	СпецСимволы.Добавить("|");
	СпецСимволы.Добавить(">");
	СпецСимволы.Добавить(".");
	СпецСимволы.Добавить("+");
	СпецСимволы.Добавить("?");
	СпецСимволы.Добавить("*");

	Для Каждого СпецСимвол Из СпецСимволы Цикл
		Шаблон = СтрЗаменить(Шаблон, СпецСимвол, "\" + СпецСимвол);
	КонецЦикла;

	Возврат Шаблон;

КонецФункции

// Дополнение к методу ОбъединитьПути 
// - разделители пути приводятся к единому разделителю, которые актуален для текущей системы
// - если в одном из путей встречается корневой слеш, то исключается получения корневого пути от диска, 
//		чем страдает метод движка ОбъединитьПути
//		ОбъединитьПути("E:\my\test", "\images", "upload\pic.png") выведет неожиданное \images\upload\pic.png
// 		а ОбъединитьПутиПравильно выведет ожидаемое E:\my\test\images\upload\pic.png
//
// Параметры:
//   Путь1 - Строка - часть пути.
//   Путь2 - Строка - часть пути.
//   Путь3 - Строка - часть пути. Необязательно.
//   Путь4 - Строка - часть пути. Необязательно.
//
//  Возвращаемое значение:
//   Строка - финальный путь с разделителями, которые актуальны для текущей системы
//
Функция ОбъединитьПути(Знач Путь1, Знач Путь2, Знач Путь3 = "", Знач Путь4 = "") Экспорт

	ВсеПути  = Новый Массив;
	ВсеПути.Добавить(Путь1);
	ВсеПути.Добавить(Путь2);
	
	Если Не ПустаяСтрока(Путь3) Тогда
		ВсеПути.Добавить(Путь3);
	КонецЕсли;

	Если Не ПустаяСтрока(Путь4) Тогда
		ВсеПути.Добавить(Путь4);
	КонецЕсли;

	Компоненты = Новый Массив;
	Для каждого Путь Из ВсеПути Цикл

		// К единому виду разделителей.
		ВремПуть = СтрЗаменить(Путь, "\", "/");
		ВремКомпоненты = СтрРазделить(ВремПуть, "/", Ложь);
		Для каждого Компонент Из ВремКомпоненты Цикл
			Компоненты.Добавить(Компонент);
		КонецЦикла;

	КонецЦикла;

	РезультирующийПуть = СтрСоединить(Компоненты, ПолучитьРазделительПути());

	Возврат РезультирующийПуть;

КонецФункции
